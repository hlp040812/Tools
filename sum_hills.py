#!/usr/bin/env python
# coding: utf-8


readme = """
File "HILLS" was generated by PLUMED. \n
Example: sum_hills.py --hills HILLS.0,HILLS.1 
                    --outfile fes.dat 
                    --bin 300,300 
                    --min -1,1 --max 2,3
                    --timeline 6
                    --movie movie
"""

import sys
from optparse import OptionParser


parser = OptionParser(usage=readme)

parser.add_option(
    "--hills", 
    type="string", 
    dest="hills",
    help="PLUMED HILLS filenames"
)

parser.add_option(
    "--bin", 
    type="string", 
    dest="bin", 
    default="200,200",
    help="how fine is plot, max 5000. default='200,200'"
)

parser.add_option(
    "--outfile", 
    type="string", 
    dest="outfile", 
    default="fes.dat",
    help="default='fes.dat'"
)

parser.add_option(
    "--min", 
    type="string", 
    dest="min", 
    default="-10,-10",
    help="default='-10,-10'"
)

parser.add_option(
    "--max", 
    type="string", 
    dest="max", 
    default="10,10",
    help="default='10,10'"
)

parser.add_option(
    "--timeline", 
    type="int", 
    dest="timeline",
    help="Plot free energy with time"
)

parser.add_option(
    "--movie", 
    type="string",
    dest="movie",
    help="make 3D movie file"
)

options, args = parser.parse_args()
# (options, args) = parser.parse_args()

para = sys.argv
# print(para)
if len(para) == 1:
    parser.print_help()
    quit()



import matplotlib.pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numpy as np
import os, cv2
from avoid_overwritting import new_file_name
import PIL.Image as Image


# print(options)
# print(args)

if options.hills == None:
    parser.error("need --hills")
fnames = options.hills.split(",")
# fnames = ['HILLS.0', 'HILLS.1']
nfiles = len(fnames)

bin = options.bin.split(",")
if len(bin) != 2:
    parser.error("Example: --bin 200,200")
gridx, gridy = list(map(int, bin))[:]

fout = new_file_name(options.outfile)

xymin, xymax = options.min.split(","), options.max.split(",")
if len(xymin) != 2 or len(xymax) != 2:
    raise parser.error("Example: --min -1,1 --max 2,3")
xlim = [float(xymin[0]), float(xymax[0])]
ylim = [float(xymin[1]), float(xymax[1])]

if options.movie != None and options.timeline == None:
    parser.error("--timeline must be defined, since --movie exists.")

####### options defined ########
################################


# generate mesh
x = np.linspace(xlim[0], xlim[1], gridx)
y = np.linspace(ylim[0], ylim[1], gridy)
X, Y = np.meshgrid(x, y)


# load PLUMED HILLS file
# time  cv1  cv2  width1  width2  height  biasf
def gaussian(hill):
    cv1, cv2, width1, width2, height = hill[1:6]
    global X, Y
    # equation found here
    # https://www.plumed.org/doc-v2.7/user-doc/html/_m_e_t_a_d.html
    return height * np.exp(-np.power(X - cv1, 2.)  \
                  / (2 * np.power(width1, 2.)))    \
                  * np.exp(-np.power(Y - cv2, 2.)  \
                  / (2 * np.power(width2, 2.)))


# load PLUMED HILLS file
# time  cv1  cv2  width1  width2  height  biasf
def read_sum(fname):
    print("read {} ...".format(fname))
    hills = np.loadtxt(fname, comments='#!')
    # Gaussian hills
    # apply gaussian on each row in hills
    ghills = np.apply_along_axis(gaussian, 1, hills)
    # ghills.shape
    # sum Gaussian hills
    gsum = np.sum(ghills, axis=0)
    # print(gsum.shape)
    return gsum


def mywrite(fout, free):
    # save sum of Gaussian hills to csv
    # negative to free energy
    print("write {}".format(fout))
    np.savetxt(fout, free)


def mycontour(free):
    global X, Y
    # figcontour = plt.figure()
    # X, Y and value for (X,Y) point
    # parameters: X, Y, f(X,Y)
    # transparent=0.75, use hot colormap
    # use plt.contourf to fill contours
    cntr = plt.contourf(X, Y, free, 8, alpha=.75, cmap=plt.cm.hot)

    # use plt.contour to add contour lines
    # 8 means contour density
    C = plt.contour(X, Y, free, 8, colors='black', linewidths=.5)

    # inline=True remove contour under the number of free energy
    # the number will cover the contour
    plt.clabel(C, inline=True, fontsize=10)
    plt.colorbar(cntr, label="FES [kJ/mol]")
    # plt.show()


def my3D(free):
    global X, Y
    # 3D plot
    # default dpi=100, figsize=(6.4, 4.8) inches
    # it means default pixel=(640, 480)
    fig3D = plt.figure()
    ax = plt.axes(projection='3d')
    s = ax.plot_surface(X, Y, free, cmap='viridis', edgecolor='none')
    plt.colorbar(s, label="FES [kJ/mol]")
    # ax.set_title('Surface plot')
    # plt.show()
    return fig3D


# convert matplotlib figure object to numpy array
def fig2array(fig):
    # draw figure
    fig.canvas.draw()
    # size of figure
    w, h = fig.canvas.get_width_height()
    # argb image
    buf = np.frombuffer(fig.canvas.tostring_argb(), dtype=np.uint8)
    # reshape to (w h 4) argb image
    buf.shape = (w, h, 4)
    # convert to RGBA
    buf = np.roll(buf, 3, axis=2)
    # Image RGBA image object
    image = Image.frombytes("RGBA", (w, h), buf.tobytes())
    # convert to numpy array 4-D
    image = np.asarray(image)
    # conver to RGB image
    rgb_image = image[:, :, :3]
    return rgb_image


##################################################################
if __name__ == '__main__':

    if options.timeline == None:
        free = np.zeros(shape=[gridx, gridy], dtype=float)
        for fname in fnames:
            gsum = read_sum(fname)
            free -= gsum
        mywrite(fout, free)
        mycontour(free)
        _ = my3D(free)
        plt.show()

    elif options.timeline != None and options.movie == None:
        # --timeline without --movie
        print("Plot free energy with time.")
        nframes = options.timeline
        # n_rows, n_cols
        nr = int(nframes**0.5)
        nc = nframes//nr
        # print(nr, nc, type(nr), type(nc))
        
        dnlines = {}  # dict number of lines
        dhills = {}   # dict hills file
        for fname in fnames:
            # fnames = ['HILLS.0', 'HILLS.1']
            # read files
            hills = np.loadtxt(fname, comments='#!')
            dhills[fname] = hills
            dnlines[fname] = hills.shape[0]


        tlplot = plt.figure(figsize=(20, 10))
        for i in range(1, nr*nc+1):
            # define partial free energy
            pfree = np.zeros(shape=[gridx, gridy], dtype=float)
            # each hill is divided into (nframes) parts,
            # each frame has (frame) number of lines
            for fname in fnames:
                frame = dnlines[fname]//nframes
                # not using def read_sum, avoid loadtxt multi times
                time = dhills[fname][frame*i-1, 0]  # fs
                time = round(float(time)/1000, 1)   # ps
                # partial gaussian hills
                # partial gaussian sum
                # partial free energy
                pghills = np.apply_along_axis(gaussian, 1, 
                                        dhills[fname][0:frame*i, :])
                pgsum = np.sum(pghills, axis=0)
                pfree -= pgsum
            
            # plt.subplot(n_rows, n_cols, plot_num)
            ax = plt.subplot(nr, nc, i)
            ax.set_title("{} ps".format(time))
            mycontour(pfree)

        plt.tight_layout()
        plt.show()

    elif options.movie:
        # --movie
        print("Making 3D movie...")

        nframes = options.timeline
        fmovie = options.movie
        
        dnlines = {}  # dict number of lines
        dhills = {}   # dict hills file
        for fname in fnames:
            # fnames = ['HILLS.0', 'HILLS.1']
            # read files
            hills = np.loadtxt(fname, comments='#!')
            dhills[fname] = hills
            dnlines[fname] = hills.shape[0]


        # filename  = Name of the output video file
        # fourcc    = codec used to compress the frames
        # fps       = Framerate of the video 
        # frameSize = Size of the video frames (watch width & height)
        # framesize = cv2.imread(imgname).shape[:2][::-1]
        framesize = (640, 480) # matplotlib default figsize
        fourcc = cv2.VideoWriter_fourcc(*'MP42')
        # fourcc = cv2.VideoWriter_fourcc(*'MJPG')
        vw = cv2.VideoWriter(filename=fmovie+".avi",
                            fourcc=fourcc, 
                            fps=20, 
                            frameSize=framesize)


        for i in range(1, nframes+1):
            # define partial free energy
            pfree = np.zeros(shape=[gridx, gridy], dtype=float)
            for fname in fnames:
                # print(fnames, fname)
                frame = dnlines[fname]//nframes
                # print(frame)
                # not using def read_sum, avoid loadtxt multi times
                # time = dhills[fname][frame*i-1, 0]  # fs
                # # print(time, type(time))
                # time = round(float(time)/1000, 1)   # ps
                # partial gaussian hills
                # partial gaussian sum
                # partial free energy
                pghills = np.apply_along_axis(gaussian, 1, 
                                        dhills[fname][0:frame*i, :])
                pgsum = np.sum(pghills, axis=0)
                pfree -= pgsum
            f = my3D(pfree)
            img = fig2array(f)
            # Release matplotlib.pyplot.figure memory:
            # has tested that, surprisingly, plt.cla() is slowest,
            # plt.clf() and plt.close() are fast equally.
            plt.close() 
            vw.write(img)
        vw.release()


    else:
        parser.error("What do you want?")


##################################################################

